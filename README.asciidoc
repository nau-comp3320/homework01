Homework 01: Syntax and semantics
=================================

Due date:: 00:00 4 Feb 2015

[NOTE]
For this assignment, it will be necessary to create graphical representations
of parse trees and a DFA.  Feel free to include images generated by a
diagramming tool like http://graphviz.org/[Graphviz] or by scanning something
you have drawn by hand.  If neither one of these options work for you, feel
free to turn in a paper to me personally, but no later than my office hours
next Tuesday.

Objectives
----------

The goal of this homework is to give you some practical experience:

* Defining:
** A syntax using BNF and EBNF
** Static semantics using an attribute grammar
* Manually applying:
** A syntax to generate a parse tree
** An attribute grammar to a parse tree
* Designing a DFA to tokenize a sentence using a grammar

Procedure
---------

=== Create rules for numbers

The grammar you are going to develop will support two types:

1. Integers, which may contain a +-+ which is immediately followed by sequence
   of one or more digits, i.e +0+, +1+, +2+, +-1+, +-2+, etc.
2. Decimals, which are like integers but are followed by a decimal point +.+
   and zero or more digits, i.e. +0.0+, +3.14159+, +-1.+, etc.

Define rules for these two types using BNF (not EBNF).

------------------------------------------------------------------------------
integer → '-' digit | digit
decimal → integer '.' digits | integer digits '.' digits
digits  → digit digit
digit   → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
------------------------------------------------------------------------------


=== Extend the grammar and add mathematical operators

Given the above rules, add the following rule:

------------------------------------------------------------------------------
number → integer | decimal

integer → '-' digit | digit
decimal → integer '.' digits | integer digits '.' digits
digits  → digit digit
digit   → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
------------------------------------------------------------------------------

Define a grammar for mathematical expressions that includes the following
features:

* It supports addition `+`, subtraction +-+, multiplication +*+, division +/+,
  exponentiation +^+, and grouping via parenthesis +(+ +)+
* These operators have the standard order of operations:
  1. Parenthetical grouping
  2. Exponentation
  3. Multiplication and division
  4. Addition and subtraction
* These operators have the standard associativity:
** Left for addition, subtraction, multiplication, and division
** Right for exponentiation

The starting rule for this grammar will be 'expression'.  Use plain BNF:

------------------------------------------------------------------------------

expression  →	expression + term | expression - term | term
term	    →	term * exponent | term / exponent | exponent
exponent    →	exponent ^ factor | factor
factor	    →	number | ( expression )


number → integer | decimal

integer → '-' <digit> | <integer> <digit>
decimal → <integer> '.' <digits> | <integer> <digits> '.' <digits>
digits  → <digit> <digit> | <digits>
digit   → 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
------------------------------------------------------------------------------


=== Use EBNF

Take the grammar you produced in the last step, and redefine it using EBNF.

------------------------------------------------------------------------------

expression -> term [ ('+' | '-') term ]*
term -> factor [ ('*' | '/') factor ]*
factor -> base [ '^' exponent ]*
base -> '(' expr ')' | rvalue
exponent -> '(' expr ')' | rvalue


------------------------------------------------------------------------------


=== Create some parse trees

Now that you have created your grammar, parse some sentences into trees.  For
example, the expression `2 + 3 * -1.` should produce something resembling the
following tree.  'Note that the following tree is incomplete and is missing
some non-terminals that are part of your grammar'.

.Parse tree for `2 + 3 * -1.`
image::example00.png["Parse tree for '2 + 3 * -1.'"]

Create parse trees for the following expressions:

1. `1 + 2 + 3 + 4`
2. `1 + 2 * 3 + 4`
3. `42 + -2. ^ ( 5 - 7.4 )`


=== Add an attribute grammar

Next, you will add attributes to the grammar you have created.  Each rule will
have two synthetic attributes:

1. 'value', the mathematical value of the node.
2. 'type', the type of the value of the node.

Note that any operation involving a decimal will be promoted to a decimal.
Otherwise, operations with only integers will result in an integer.

For example:

------------------------------------------------------------------------------
sum → number[1] + number[2]
  sum.value ← number[1].value + number[2].value
  sum.type ← if (number[1].type == decimal) or (number[2].type == decimal) then
               decimal
	     else
	       integer

number → integer
  number.value ← integer.value
  number.type ← integer.type

number → decimal
  number.value ← decimal.value
  number.type ← decimal.type

integer →
  integer.value ← (value of integer literal)
  integer.type ← integer
------------------------------------------------------------------------------


=== Perform some static semantic analysis


Now that you added semantics to your grammar, revisit the parse trees you
generated earlier and add the semantic attributes.  'Remember that the following
parse tree is missing some non-terminals for your grammar.'

.Parse tree for `2 + 3 * -1.` with semantic values
image::example01.png["Parse tree for '2 + 3 * -1.' with semantic values"]

Add semantic values for the parse trees that you generated from the following
expressions:

1. `1 + 2 + 3 + 4`
2. `1 + 2 * 3 + 4`
3. `42 + -2. ^ ( 5 - 7.4 )`


=== Design a lexical analyser

Finally, it's time to design a DFA that you will use to create a lexical
analyser for your grammar.  Here is an example of a DFA that will recognise
integers, plus operator `+`, and discards white space.

.A state diagram for a simple lexical analyser
image::example02.png["A simple state diagram for a lexical analyser that consumes white space, recognises integers, and recognises the plus operator.]

You can also use a state transition table, as in:

[options="header"]
|=============================================================================
|       |digit  |white space         |plus                           |end of input
|default|integer|default             |default/AddOpToken             |accept
|integer|integer|default/IntegerToken|default/IntegerToken,AddOpToken|accept/IntegerToken
|=============================================================================
